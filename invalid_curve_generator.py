"""
Author: forensicskween

Invalid Curve Generator for Elliptic Curve Cryptography (ECC)

This module generates invalid elliptic curves for testing and attack simulations. 
It allows users to:
- Randomly generate invalid curves with small order factors.
- Precompute and save invalid curves for faster attack execution.
- Specify custom `b` values or generate random ones.

Example Usage:
---------------
To generate 10 invalid curves:
    python invalid_curve_generator.py --p <prime> --a <curve_a> --x 10 --output invalid_curves.json

To specify `b` values:
    python invalid_curve_generator.py --p <prime> --a <curve_a> --numbers 123,456,789 --output invalid_curves.json

Dependencies:
-------------
- SageMath (for elliptic curve operations)
"""

# This file was *autogenerated* from the file invalid_curve_attack.sage
from sage.all_cmdline import *   # Import SageMath library

# Standard Library Imports
import argparse
import json
import logging
import os
import random
import time
from typing import List, Tuple, Optional, Dict, Union

# Local Logging Setup
from logger import setup_logger

# SageMath Imports
from sage.all import EllipticCurve, GF, is_prime
from sage.schemes.elliptic_curves.ell_point import EllipticCurvePoint

# Shared Utilities (after fixing the path)
from shared.factor_help import get_factors, loop_func_with_timeout, call_factordb, fact_dict


def find_b(b_values: Optional[List[int]], p: int, attempted_b_values: set) -> Optional[int]:
    """
    Finds a valid `b` value for elliptic curve generation.
    
    Args:
        b_values (Optional[List[int]]): User-provided `b` values (if any).
        p (int): Prime modulus of the finite field.
        attempted_b_values (set): Set of already attempted `b` values.

    Returns:
        Optional[int]: A valid `b` value, or `None` if exhausted or invalid.
    """
    if b_values is not None:
        while b_values:  # 🔥 Ensure we don’t pop from an empty list
            b = b_values.pop(0)

            # 🔥 Validate user-provided `b`
            if b < 1 or b >= p:
                logging.warning(f"Invalid user-provided b={b}. Must be in range [1, p-1]. Skipping.")
                continue  # Skip this invalid `b` and try the next one
            
            return b  # Return valid `b`

        return None  # No valid `b` values left

    # 🔥 Randomly find a valid `b`, ensuring uniqueness
    while True:
        b = random.randint(1, p - 1)
        if b not in attempted_b_values:
            attempted_b_values.add(b)
            return b


def parse_range(n: str) -> List[int]:
    """Parse a range input from argparse."""
    try:
        if ',' in n:
            start, end = map(int, n.split(','))
            return list(range(start, end + 1 ))  # Include end value
        return list(range(int(n)))  # Single integer case
    except ValueError:
        raise argparse.ArgumentTypeError("Range must be a single integer or two integers separated by a comma")


def parse_numbers(value: str) -> List[int]:
    """Parse numbers from a file or a comma-separated string."""
    if os.path.isfile(value):
        with open(value, 'r') as f:
            return [int(line.strip()) for line in f]
    try:
        return [int(value)] if value.isdigit() else list(map(int, value.split(',')))
    except ValueError:
        raise argparse.ArgumentTypeError("Value must be a single integer or a list of integers separated by commas")


class InvalidCurveGenerator:
    """
    A class to generate invalid elliptic curves for cryptographic attacks.

    This class facilitates the generation of elliptic curves with manipulated parameters
    to test invalid curve attacks. It provides methods to compute curve orders, factorize 
    them, and generate specific curve parameters.

    Attributes:
        p (int): The prime modulus defining the finite field GF(p).
        a (int): The coefficient 'a' of the elliptic curve equation y² = x³ + ax + b.
        gf (FiniteField): The Galois field GF(p) associated with the curve.
        timeout (int): The timeout for order calculations in seconds.
        timeout_max (int): The maximum timeout for order computations.
        factor_ints (bool): Whether to factorize the order of the elliptic curve.
        proof (bool): Whether to ensure all factors are prime.
        deep (bool): Whether to perform deep factorization (ECM) for the order.
    
    The actual attack is in the file invalid_attack.py. 
    """

    def __init__(self, p: int, a: int, timeout: int, timeout_max: int, factor_ints: bool, proof: bool, deep: bool):
        """
        Initializes the InvalidPreimage instance with curve parameters.

        Args:
            p (int): The prime modulus for the finite field GF(p).
            a (int): The coefficient 'a' in the elliptic curve equation.
            timeout (int): The timeout in seconds for computing curve orders.
            timeout_max (int): The maximum timeout allowed for order calculations.
            factor_ints (bool): Whether to perform factorization of the curve order.
            proof (bool): Whether to enforce that all factors are prime.
            deep (bool): Whether to use deep factorization techniques (ECM).

        Raises:
            ValueError: If p is not a prime number or if invalid arguments are provided.
        """
        self.p = p
        self.a = a
        self.gf = GF(p)
        self.timeout = timeout
        self.timeout_max = timeout_max
        self.factor_ints  = factor_ints
        self.proof = proof
        self.deep = deep

    def get_curve_order(self, curve: EllipticCurve) -> Optional[int]:
        """Compute the order of an elliptic curve with a timeout."""
        return loop_func_with_timeout(curve.order, timeout=self.timeout, max_timeout=self.timeout_max)

    
    def get_factors_order(self, order: int, deep: bool = False) -> Tuple[Optional[List[int]], Optional[List[int]]]:
        """Factorize the order of an elliptic curve."""
        try:
            return get_factors(order, self.timeout, max_timeout=self.timeout_max, factor_dict=True) if deep else (
                call_factordb(order), fact_dict(call_factordb(order))
            )
        except Exception:
            return None, None

    
    @staticmethod
    def gen_proof(facs: List[int]) -> bool:
        """Verify if all factors are prime."""
        return all(is_prime(x) for x in facs)

    
    def get_g(self, curve: EllipticCurve) -> Optional[EllipticCurvePoint]:
        """Obtain a generator point of the elliptic curve."""
        return loop_func_with_timeout(curve.gen, 0 , timeout=self.timeout, max_timeout=self.timeout_max)

    def generate_curves(
        self, 
        target: Optional[int] = None, 
        b_values: Optional[List[int]] = None, 
        g0: bool = False, 
        target_len: Optional[int] = None, 
        save_path: Optional[str] = None
    ) -> List[Dict]:
        """
        Generate invalid elliptic curves until `target` valid curves are obtained.
        
        Handles three cases:
        1. `target` is provided → Generates `target` random `b` values.
        2. `b_values` is provided → Uses predefined `b` values from a list.
        3. Periodically saves progress to prevent data loss.

        Args:
            target (Optional[int]): Number of valid curves to generate (random mode).
            b_values (Optional[List[int]]): Predefined `b` values from `--numbers` or `--range`.
            g0 (bool): Whether to compute generator points.
            target_len (Optional[int]): Minimum factorization length required.
            save_path (Optional[str]): File path to save intermediate results.

        Returns:
            List[Dict]: List of valid curve data dictionaries.
        """
        out_curves = []
        attempted_b_values = set()  # Avoid duplicates in random mode
        b_values_copy = None
        if b_values is not None:
            b_values_copy = b_values[:]  # 🔥 Create a copy so we don’t modify the original list
            target = len(b_values)  # Ensure we only process user-provided values

        while len(out_curves) < target:
            b = find_b(b_values, self.p, attempted_b_values)
            if b is None:
                break  # Stop if `b_values` exhausted

            logging.info(f"Processing curve {len(out_curves) + 1 }/{target}: b = {b}")

            try:
                curve_data = self.process_curve(b, g0, target_len)
                if curve_data:
                    out_curves.append(curve_data)

                # Save progress every 5 successful curves
                if save_path and len(out_curves) % 5  == 0 :
                    self.save_partial_results(out_curves, save_path)

            except Exception as e:
                logging.error(f"Error processing b={b}: {e}")
                if save_path:
                    self.save_partial_results(out_curves, save_path)  # Save before failing
        

        if b_values_copy is not None and len(out_curves) == 0:
            raise ValueError("All user-provided b values failed. No valid curves generated.")

        if b_values_copy is not None and len(out_curves) != target:
            logging.warning(f"Some user-provided b values failed. Expected {target}, but only {len(out_curves)} valid curves were generated.")
        
        return out_curves
    


    def process_curve(self, b: int, g0: bool, target_len: Optional[int]) -> Optional[Dict]:
        """
        Processes a single curve given a `b` value.

        Args:
            b (int): The coefficient `b` for the elliptic curve.
            g0 (bool): Whether to compute generator points.
            target_len (Optional[int]): Minimum factorization length required.

        Returns:
            Optional[Dict]: The curve data dictionary, or None if invalid.
        """
        if b < 1  or b >= self.p:
            logging.warning(f"Skipping invalid b value: {b} (must be in range [1, p-1])")
            return None  # Skip processing this curve instead of raising an error
        try:
            E = EllipticCurve(self.gf, [self.a, b])
            order = self.get_curve_order(E)
            if not order:
                return None

            # Factorization
            facs, facs_exp = self.get_factors_order(order, self.deep) if self.factor_ints else (None, None)
            if self.factor_ints and not facs:
                logging.warning(f"Skipping: Factorization failed for order {order}")
                return None

            if target_len is not None and facs_exp and len(facs_exp) < target_len:
                logging.warning(f"Skipping b={b}: Insufficient factorization length ({len(facs_exp)}/{target_len})")
                return None

            curve_data = {'b': int(b), 'order': int(order)}
            if facs and facs_exp:
                curve_data.update({'factors': list(map(int,facs)), 'factors_exp': list(map(int,facs_exp))})

            if g0:
                G = self.get_g(E)
                if G is None:
                    return None
                curve_data['G'] = list(map(int, G.xy()))

            return curve_data

        except Exception as e:
            logging.error(f"Error processing curve b={b}: {e}")
            return None

    def save_partial_results(self, out_curves: List[Dict], save_path: str):
        """
        Saves collected curve data to a file to prevent data loss.

        Args:
            out_curves (List[Dict]): List of generated curves.
            save_path (str): Path to save the data.
        """
        try:
            order_dict = {'curve_params': {'a': int(self.a), 'p': int(self.p)}, 'curves': out_curves}
            with open(save_path, 'w') as f:
                json.dump(order_dict, f, indent=4 )
            logging.info(f"✅ Progress saved to {save_path}")
        except Exception as e:
            logging.error(f"⚠️ Failed to save progress: {e}")



def main():
    try:
        setup_logger(logging.INFO, log_file="generator.log")
    except Exception as e:
        print(f"⚠️ Logging setup failed: {e}")  # Fallback to console output

    logging.info("Starting Invalid Curve Generator...")

    start = time.time()

    parser = argparse.ArgumentParser(description="Generate invalid elliptic curve parameters.")

    # Required curve parameters
    parser.add_argument("--p", type=str, required=True, help="Prime number p for the finite field GF(p)")
    parser.add_argument("--a", type=str, required=True, help="Coefficient a of the elliptic curve")

    # Optional parameters
    parser.add_argument("--factor", action="store_true", help="Factorize the curve order")
    parser.add_argument("--proof", action="store_true", help="Ensure all factors are prime (only if --factor is set)")
    parser.add_argument("--g", action="store_true", help="Include generator points")
    parser.add_argument("--d", action="store_true", help="Enable deep factorization (ECM)")
    parser.add_argument("--output", type=str, help="Output file to save the resulting dictionary")
    parser.add_argument("--t", type=int, default=5 , help="Timeout for order calculation (default: 5)")
    parser.add_argument("--target_len", type=int, default=5 , help="Minimum required number of factors")

    # Mutually exclusive group: User must pick only one method to provide `b` values
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--x", type=int, help="Number of random curves to generate")
    group.add_argument("--numbers", type=parse_numbers, help="File, list, or single number for specific curves")
    group.add_argument("--range", type=parse_range, help="Range (start,end) or single number for multiple curves")

    args = parser.parse_args()

    p, a = eval(args.p), eval(args.a)

    if args.factor and args.proof:
        logging.info("Factor and proof enabled")
    
    # Determine `b_values` based on the chosen argument
    if args.numbers:
        b_values = args.numbers
        logging.info(f"Using numbers provided: {b_values}")
    elif args.range:
        b_values = args.range
        logging.info(f"Using range provided: {b_values}")
    else:
        b_values = None  # `x` is used for random generation

    logging.info("Initializing attack parameters...")

    # Initialize curve attack class
    curve_attack = InvalidCurveGenerator(
        p, a, timeout=1 , timeout_max=args.t, factor_ints=args.factor, proof=args.proof, deep=args.d
    )

    # Run curve generation
    if args.x:
        values = curve_attack.generate_curves(target=args.x, g0=args.g,save_path=args.output)
    else:
        values = curve_attack.generate_curves(b_values=b_values, g0=args.g, target_len=args.target_len,save_path=args.output)

    output_dict = {'curve_params': {'a': int(a), 'p': int(p)}, 'curves': values}
    end = time.time()
    logging.info(f"Execution time: {end - start:.2f} seconds")

    if args.output:
        with open(args.output, 'w') as f:
            f.write(str(output_dict))
        logging.info(f"Results saved to {args.output}")
    else:
        logging.info(f"Generated Curves: {output_dict}")

        
if __name__ == "__main__":
    main()
 


