"""
Author: forensicskween

Invalid Curve Attack on Elliptic Curve Cryptography (ECC)

This module provides the implementation of an Invalid Curve Attack against 
Elliptic Curve Cryptography (ECC). It allows users to:
- Load precomputed invalid curves.
- Execute an attack using an oracle function.
- Recover the discrete logarithm by leveraging invalid curve vulnerabilities.

⚠️ This module is NOT meant to be run as a standalone script. Instead, import and use:
    from invalid_curve_attack import run_attack

Example Usage:
---------------
from invalid_curve_attack import run_attack

b = original_b_from_the_servers_curve
attack_dict_file = "curve_params.json"

def oracle(P):
    result = server_function_that_multiplies_P_with_secret(P.xy())
    return result

run_attack(attack_dict_file, oracle, b)

Dependencies:
-------------
- SageMath (for elliptic curve operations)
"""

# This file was *autogenerated* from the file invalid_curve_attack.sage
from sage.all_cmdline import *   # import sage library
import random
from sage.all import EllipticCurve, ZZ, factor, GF, crt
import json
import logging
from logger import setup_logger

# Initialize logger
setup_logger(logging.INFO, log_file="attack.log")
logging.info("Starting invalid curve attack...")


def create_invalid_curve(E):
    """
    Generate an invalid elliptic curve by modifying the `b` parameter while keeping `a` the same.

    Args:
        E (EllipticCurve): The original elliptic curve.

    Returns:
        tuple: (E0, G0, small_factors)
            - `E0` (EllipticCurve): The newly created invalid elliptic curve.
            - `G0` (EllipticCurvePoint): A generator point on `E0`.
            - `small_factors` (list[int]): Small prime factors (≤40 bits) of the order of `G0`.
    """
    gf = E.base_ring()
    p = gf.order()
    a = E.ainvs()[3 ]
    b = random.randint(0 , p - 1 )
    
    E0 = EllipticCurve(gf, [a, b])
    G0 = E0.gens()[0 ]
    order = G0.order()
    
    factors = [x[0 ] ** x[1 ] for x in factor(order)]
    small_factors = [ZZ(x) for x in factors if x.bit_length() <= 40 ]
    
    return E0, G0, small_factors


def load_invalid_curves_from_params(attack_dict, b):
    """
    Load precomputed invalid elliptic curves from an attack dictionary.

    Args:
        attack_dict (dict): A dictionary containing attack parameters.
            Expected keys:
            - `curve_params`: A dictionary containing:
                - `p` (int): Prime modulus of the field.
                - `a` (int): Parameter `a` of the elliptic curve equation.
            - `curves`: A list of precomputed invalid curve data, each containing:
                - `b` (int): Parameter `b` of the invalid curve.
                - `order` (int): Order of the modified curve.
                - `factors_exp` (list[int]): Factorization of the order.
                - `G` (tuple[int, int]): Coordinates of a generator point.
        b (int): The `b` coefficient to initialize the main curve.

    Returns:
        tuple: (E, G0, output_params)
            - `E` (EllipticCurve): The elliptic curve initialized from attack parameters.
            - `G0` (EllipticCurvePoint): A generator point on `E`.
            - `output_params` (list[tuple]): A list of tuples `(bad_E, bad_G, small_factors)`, where:
                - `bad_E` (EllipticCurve): An invalid precomputed elliptic curve.
                - `bad_G` (EllipticCurvePoint): Generator point on `bad_E`.
                - `small_factors` (list[int]): Small prime factors (≤40 bits) of the order of `bad_G`.
    """
    output_params = []
    gf = GF(attack_dict['curve_params']['p'])
    a = attack_dict['curve_params']['a']
    
    E = EllipticCurve(gf, [a, b])
    G0 = E.gen(0 )

    for bad_curve in attack_dict['curves']:
        small_factors = [ZZ(x) for x in bad_curve['factors_exp'] if x.bit_length() <= 40 ]
        if small_factors:
            bad_E = EllipticCurve(gf, [a, bad_curve['b']])
            bad_E.set_order(bad_curve['order'])
            bad_G = bad_E(*bad_curve['G'])
            output_params.append((bad_E, bad_G, small_factors))

    return E, G0, output_params


def verify_dlog(oracle, E, G, P):
    """
    Verify whether the discrete logarithm computed by the oracle is correct.

    Args:
        oracle (callable): A function that takes a point and returns an oracle response.
        E (EllipticCurve): The elliptic curve.
        G (EllipticCurvePoint): The base generator point.
        P (EllipticCurvePoint): The target point for verification.

    Returns:
        bool: True if `oracle(G)` correctly maps to `P`, otherwise False.
    """
    result = oracle(G)
    return E(result) == P


def compute_dlog_round(oracle, E, G=None, factors=None):
    """
    Perform one round of the discrete logarithm attack using an oracle.

    This function attempts to compute the discrete logarithm of a given point
    using an oracle and small factorization of the group order.

    Args:
        oracle (callable): A function that takes an elliptic curve point and returns an oracle response.
        E (EllipticCurve): The elliptic curve on which computations occur.
        G (EllipticCurvePoint, optional): The base generator point. Defaults to the first generator of `E`.
        factors (list[int], optional): A list of prime power factors of the order of `G`.

    Returns:
        tuple: (logs, modulis)
            - `logs` (list[int]): The list of discrete logarithm values obtained.
            - `modulis` (list[int]): The corresponding moduli for the computed logs.
    """
    logs, modulis = [], []

    if G is None:
        G = E.gens()[0 ]

    g_ord = G.order()
    factors = factors or [x[0 ]**x[1 ] for x in factor(g_ord)]

    for fac in factors:
        if g_ord % fac == 0: 
            try:
                P = G * (g_ord // fac)
                Q = oracle(P)
                if not Q:
                    continue
                try:
                    Q = E(Q)
                except:
                    continue
                if not Q.is_zero() and Q != P:
                    logged = P.discrete_log(Q)
                    logs.append(logged)
                    modulis.append(fac)
            except (ArithmeticError, ValueError) as e:
                print(f"Error in discrete log computation: {e}")
                pass

    return logs, modulis


def precomputed_attack(oracle, E, G, params, P=None):
    """
    
    Perform an invalid curve attack using precomputed invalid curves.

    This method loads a set of precomputed invalid elliptic curves and attempts to
    compute the discrete logarithm using the oracle.

    Args:
        oracle (callable): A function that takes an elliptic curve point and returns an oracle response.
        E (EllipticCurve): The target elliptic curve.
        G (EllipticCurvePoint): The base generator point.
        params (list[tuple]): A list of tuples `(E_bad, G_bad, small_factors)` representing precomputed invalid curves.
        P (EllipticCurvePoint, optional): The target point for discrete logarithm computation. Defaults to `oracle(G)`.

    Returns:
        int or tuple: The discrete logarithm `d` if found; otherwise, returns `(logs, modulis)`.
    """
    P = E(oracle(G)) if P is None else P
    logs, modulis = [], []

    for i, param in enumerate(params):
        print(f'Round {i}')
        l, m = compute_dlog_round(oracle, param[0 ], G=param[1 ], factors=param[2 ])
        logs.extend(l)
        modulis.extend(m)

        d = crt(logs, modulis)
        if d * G == P:
            print(f'Found {d}')
            return d

    return logs, modulis


def random_curve_attack(oracle, E, G, P=None, max_attempts=1000 ):
    """
    Perform an invalid curve attack by generating random invalid curves dynamically.

    WARNING: ⚠️ This method can take a very long time due to `factor()` in Sage,
    which performs integer factorization on the order of elliptic curve points. 

    This method repeatedly generates invalid elliptic curves and attempts to
    compute the discrete logarithm using the oracle until a solution is found
    or the maximum number of attempts is reached.

    Args:
        oracle (callable): A function that takes an elliptic curve point and returns an oracle response.
        E (EllipticCurve): The target elliptic curve.
        G (EllipticCurvePoint): The base generator point.
        P (EllipticCurvePoint, optional): The target point for discrete logarithm computation. Defaults to `oracle(G)`.
        max_attempts (int, optional): The maximum number of attempts before giving up. Defaults to 1000.

    Returns:
        int or tuple: The discrete logarithm `d` if found; otherwise, returns `(logs, modulis)`.
    """
    print("⚠️ WARNING: This attack may take a long time due to integer factorization (factor()) in Sage.")

    P = E(oracle(G)) if P is None else P
    logs, modulis = [], []

    for attempt in range(max_attempts):
        E0, G0, factors = create_invalid_curve(E)
        l, m = compute_dlog_round(oracle, E0, G=G0, factors=factors)
        logs.extend(l)
        modulis.extend(m)

        d = crt(logs, modulis)
        if d * G == P:
            print(f'Found {d}')
            return d

    print("Max attempts reached. Attack unsuccessful.")
    return logs, modulis


def run_attack(attack_dict_file, oracle, b):
    """
    Executes the invalid curve attack using precomputed parameters if available.
    If no precomputed invalid curves are found, it warns the user.

    Args:
        attack_dict_file (str): Path to the JSON file containing precomputed curves.
        oracle (callable): The oracle function.
        b (int): The `b` coefficient to initialize the target curve.

    Returns:
        int or tuple: The discrete logarithm if found; otherwise, logs and moduli.
    """
    logging.info(f"Loading attack parameters from {attack_dict_file}...")

    # Load attack parameters
    try:
        with open(attack_dict_file, "r") as f:
            attack_dict = json.load(f)
    except FileNotFoundError:
        logging.error(f"Error: Precomputed attack file '{attack_dict_file}' not found.")
        return None

    # Ensure precomputed curves exist
    if not attack_dict.get("curves"):
        logging.warning("⚠️ Warning: No precomputed invalid curves found. The attack may be significantly slower.")

    # Load the target curve
    gf = GF(attack_dict["curve_params"]["p"])
    a = attack_dict["curve_params"]["a"]
    E = EllipticCurve(gf, [a, b])
    G = E.gen(0 )

    # Run attack with or without precomputed curves
    if attack_dict.get("curves"):
        params = load_invalid_curves_from_params(attack_dict, b)[2 ]
        logging.info(f"Starting precomputed attack on elliptic curve with p={attack_dict['curve_params']['p']}")
        return precomputed_attack(oracle, E, G, params)
    else:
        logging.info(f"Starting attack without precomputed curves (may take longer)...")
        return random_curve_attack(oracle, E, G)


